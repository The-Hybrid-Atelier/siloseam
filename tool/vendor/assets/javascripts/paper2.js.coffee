window.loadCustomLibraries = ->

  ###Map path's perimeter points into jsclipper format
  [[{X:30,Y:30},{X:130,Y:30},{X:130,Y:130},{X:30,Y:130}]]
  ###

  toClipperPoints = (path, offset = 1) ->
    points = _.range(0, path.length, offset)
    points = _.map(points, (i) ->
      p = path.getPointAt(i)
      {
        X: p.x
        Y: p.y
      }
    )
    [ points ]
    # compound paths

  console.log 'Loading custom libraries!'
  if !paper.Item::setRampPoint

    paper.Item::setRampPoint = ->

  paper.Path.Join =
    square: ClipperLib.JoinType.jtSquare
    round: ClipperLib.JoinType.jtRound
    miter: ClipperLib.JoinType.jtMiter
  paper.Path.Alignment =
    interior: -1
    centered: 0
    exterior: 1

  paper.CompoundPath::expand = (o) ->
    # SETUP
    scale = 1000
    endType = ClipperLib.EndType.etClosedPolygon
    joinType = paper.Path.Join[o.joinType]
    deltas = [ paper.Path.Alignment[o.strokeAlignment] * o.strokeOffset / 2.0 ]
    
    children_paths = _.map this.children, (c)->
        cp = toClipperPoints(c, 1)
        ClipperLib.JS.ScaleUpPaths cp, scale
        return cp

    # CLIPPER ENGINE
    co = new (ClipperLib.ClipperOffset)
    # constructor
    offsetted_paths = new (ClipperLib.Paths)
    # empty solution
    _.each deltas, (d) ->
      co.Clear()
      co.AddPaths children_paths[0], joinType, endType
      co.AddPaths children_paths[1], joinType, endType
      co.MiterLimit = 2
      co.ArcTolerance = 0.25
      co.Execute offsetted_paths, d * scale
      return
    if offsetted_paths.length == 0
        return null
    result_paths = []
    i = 0
    offsetted_paths = ClipperLib.JS.Lighten(offsetted_paths, 0.1 * scale)
    while i < offsetted_paths.length
      segs = []
      clipperStrokePath = new (paper.Path)(closed: true)
      j = 0
      while j < offsetted_paths[i].length
        p = new (paper.Point)(offsetted_paths[i][j].X, offsetted_paths[i][j].Y)
        p = p.divide(scale)
        segs.push p
        j++
      clipperStrokePath.addSegments segs
      clipperStrokePath.set o
      result_paths.push clipperStrokePath
      i++

    if result_paths.length == 1
      result_paths[0]
    else
      cp = new (paper.CompoundPath)(children: result_paths)
      cp.set o
      cp

    
  paper.Group::ungroup = ()->
    _.each this.removeChildren(), (child)->
      paper.project.activeLayer.appendTop(child)
    this.remove()
  paper.Path::expand = (o) ->
    # SETUP
    endType = ClipperLib.EndType.etClosedPolygon
    joinType = paper.Path.Join[o.joinType]
    deltas = [ paper.Path.Alignment[o.strokeAlignment] * o.strokeOffset / 2.0 ]
    paths = toClipperPoints(this, 1)
    ClipperLib.JS.ScaleUpPaths paths, scale = 1000
    # CLIPPER ENGINE
    co = new (ClipperLib.ClipperOffset)
    # constructor
    offsetted_paths = new (ClipperLib.Paths)
    # empty solution
    _.each deltas, (d) ->
      co.Clear()
      co.AddPaths paths, joinType, endType
      co.MiterLimit = 2
      co.ArcTolerance = 0.25
      co.Execute offsetted_paths, d * scale
      return
    if offsetted_paths.length == 0
      return null
    
    result_paths = []
    i = 0
    offsetted_paths = ClipperLib.JS.Lighten(offsetted_paths, 0.1 * scale)

    while i < offsetted_paths.length
      segs = []
      clipperStrokePath = new (paper.Path)(closed: true)
      j = 0
      while j < offsetted_paths[i].length
        p = new (paper.Point)(offsetted_paths[i][j].X, offsetted_paths[i][j].Y)
        p = p.divide(scale)
        segs.push p
        j++
      clipperStrokePath.addSegments segs
      clipperStrokePath.set o
      result_paths.push clipperStrokePath
      i++
    # return clipperStrokePath;
    if result_paths.length == 1
      result_paths[0]
    else
      cp = new (paper.CompoundPath)(children: result_paths)
      cp.set o
      cp

  return

# ---
# generated by js2coffee 2.2.0